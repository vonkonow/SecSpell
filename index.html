<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SecSpell</title>
    <style>
        :root { --bg: #f5f5f5; --bg-light: #fafafa; --container-bg: #ffffff; --border: #ddd; --border-light: #e0e0e0; --text: #333; --text-muted: #666; --text-light: #555; --primary: #0066cc; --primary-hover: #0052a3; --primary-active: #003d7a; --danger: #dc3545; --danger-hover: #c82333; --success: #4caf50; --error: #ff6b6b; --error-hover: #ff5252; --hover-bg: rgba(0,0,0,0.05); --header-bg: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 50%, #e3f2fd 100%); --header-border: #90caf9; --header-text: #0d47a1; --text-area-bg: #ffffff; --suggestion-hover: #f5f5f5; --suggestion-highlight: #e3f2fd; --loading-bg: #e3f2fd; --loading-text: #1976d2; --status-warning-bg: #fff3cd; --status-warning-border: #ffc107; --status-warning-text: #856404; --status-success-bg: #e8f5e9; --status-success-text: #2e7d32; --placeholder: #adb5bd; }
        [data-theme="dark"] { --bg: #1a1a1a; --bg-light: #2d2d2d; --container-bg: #252525; --border: #404040; --border-light: #353535; --text: #e0e0e0; --text-muted: #a0a0a0; --text-light: #b0b0b0; --primary: #4a9eff; --primary-hover: #6bb3ff; --primary-active: #3a8fef; --danger: #ff5252; --danger-hover: #ff6b6b; --success: #66bb6a; --error: #ff6b6b; --error-hover: #ff5252; --hover-bg: rgba(255,255,255,0.1); --header-bg: linear-gradient(135deg, #1e3a5f 0%, #2d4a6f 50%, #1e3a5f 100%); --header-border: #3d5a7f; --header-text: #8bb4ff; --text-area-bg: #2d2d2d; --suggestion-hover: #353535; --suggestion-highlight: #3d5a7f; --loading-bg: #1e3a5f; --loading-text: #8bb4ff; --status-warning-bg: #4a3d1f; --status-warning-border: #ffa726; --status-warning-text: #ffcc80; --status-success-bg: #1b3a1f; --status-success-text: #81c784; --placeholder: #666; }
        * { box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 20px; background: var(--bg); min-height: 100vh; display: flex; flex-direction: column; }
        .container { background: var(--container-bg); border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 24px; max-width: 800px; width: 100%; margin: 0 auto; display: flex; flex-direction: column; flex: 1; min-height: 0; }
        .header { display: flex; align-items: center; gap: 16px; margin-bottom: 16px; padding: 8px 12px; background: var(--header-bg); border-radius: 6px; border: 1px solid var(--header-border); flex-wrap: wrap; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
        .header-left { display: flex; align-items: baseline; gap: 8px; flex: 1; }
        h1 { margin: 0; color: var(--header-text); font-size: 22px; font-weight: 600; text-shadow: 0 1px 2px rgba(0,0,0,0.3); }
        .subtitle { color: var(--text-muted); margin: 0; font-size: 13px; line-height: 1; }
        .header-actions { display: flex; align-items: center; gap: 12px; }
        .language-selector { display: flex; align-items: baseline; gap: 8px; }
        .language-selector label { margin: 0; font-weight: 500; color: var(--text); font-size: 13px; white-space: nowrap; cursor: pointer; text-decoration: underline; text-decoration-color: transparent; transition: text-decoration-color 0.2s; }
        .language-selector label:hover { text-decoration-color: var(--text); }
        .language-selector .radio-group { display: flex; gap: 12px; align-items: baseline; }
        .language-selector .radio-option { display: flex; align-items: baseline; cursor: pointer; gap: 6px; }
        .language-selector input[type="radio"] { margin: 0; cursor: pointer; flex-shrink: 0; }
        .language-selector .radio-option label { margin: 0; cursor: pointer; font-size: 13px; color: var(--text-light); user-select: none; }
        .language-selector .radio-option:hover label { color: var(--text); }
        #text-area { width: 100%; min-height: 300px; flex: 1; padding: 12px; font-size: 15px; line-height: 1.6; border: 1px solid var(--border); border-radius: 6px; font-family: inherit; background: var(--text-area-bg); color: var(--text); resize: vertical; transition: border-color 0.2s; white-space: pre-wrap; }
        #text-area:focus { outline: none; border-color: var(--text-muted); }
        #text-area:empty:before { content: attr(placeholder); color: var(--placeholder); pointer-events: none; }
        .spell-error { background: linear-gradient(transparent 0, transparent 85%, var(--error) 85%); cursor: pointer; border-radius: 2px; }
        .spell-error:hover { background: linear-gradient(transparent 0, transparent 85%, var(--error-hover) 85%); }
        .spell-ignored { border-bottom: 1px dotted var(--text-muted); cursor: pointer; color: var(--text-muted); }
        .spell-ignored:hover { background: var(--hover-bg); border-bottom-color: var(--text-muted); }
        .suggestions-menu { position: fixed; background: var(--container-bg); border: 1px solid var(--border); border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.3); padding: 4px 0; min-width: 160px; max-height: 200px; overflow-y: auto; z-index: 1000; display: none; }
        .suggestions-menu.show { display: block; }
        .suggestion-item { padding: 8px 12px; cursor: pointer; font-size: 14px; color: var(--text); }
        .suggestion-item:hover { background: var(--suggestion-hover); }
        .suggestion-item:first-child { font-weight: 600; color: var(--text); border-bottom: 1px solid var(--border-light); }
        .suggestion-item.highlighted { background: var(--suggestion-highlight); }
        .loading, .status { margin-top: 12px; padding: 10px 12px; border-radius: 6px; font-size: 14px; display: none; }
        .loading.active, .status.active { display: block; }
        .loading.active { background: var(--loading-bg); color: var(--loading-text); display: flex; align-items: center; gap: 10px; }
        .spinner { width: 16px; height: 16px; border: 2px solid rgba(139, 180, 255, 0.3); border-top-color: var(--loading-text); border-radius: 50%; animation: spin 0.6s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .status.has-errors { background: var(--status-warning-bg); border: 1px solid var(--status-warning-border); color: var(--status-warning-text); }
        .status.no-errors { background: var(--status-success-bg); border: 1px solid var(--success); color: var(--status-success-text); }
        .status-row { display: flex; justify-content: flex-end; align-items: center; gap: 12px; margin-top: 12px; position: relative; }
        .status-row .status { margin-top: 0; flex: 1; position: absolute; left: 0; }
        button { border: none; cursor: pointer; border-radius: 6px; font-size: 14px; transition: background 0.2s, color 0.2s; }
        .ai-button-bottom { padding: 10px 16px; background: var(--primary); color: white; font-weight: 500; white-space: nowrap; }
        .ai-button-bottom:hover { background: var(--primary-hover); }
        .ai-button-bottom:active { background: var(--primary-active); }
        .settings-button { background: none; padding: 6px; color: var(--text-muted); font-size: 18px; line-height: 1; border-radius: 4px; }
        .settings-button:hover { color: var(--text); background: var(--hover-bg); }
        .settings-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 2000; align-items: center; justify-content: center; display: none; }
        .settings-modal.show { display: flex; }
        .settings-content { background: var(--container-bg); border-radius: 8px; padding: 24px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 4px 16px rgba(0,0,0,0.3); }
        .settings-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .settings-header h2 { margin: 0; font-size: 20px; color: var(--text); }
        .settings-close { background: none; font-size: 24px; color: var(--text-muted); padding: 0; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 4px; }
        .settings-close:hover { background: var(--hover-bg); }
        .settings-item { margin-bottom: 20px; }
        .settings-item label { display: flex; align-items: center; gap: 10px; cursor: pointer; font-size: 14px; color: var(--text); }
        .settings-item input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; }
        .settings-item-description { font-size: 12px; color: var(--text-muted); margin-top: 4px; margin-left: 28px; }
        .settings-link { display: inline-flex; align-items: center; gap: 6px; color: var(--primary); text-decoration: none; font-size: 14px; padding: 6px 0; transition: color 0.2s; }
        .settings-link:hover { color: var(--primary-hover); text-decoration: underline; }
        .settings-separator { height: 1px; background: var(--border-light); margin: 20px 0; }
        .settings-button-danger { padding: 8px 16px; background: var(--danger); color: white; }
        .settings-button-danger:hover { background: var(--danger-hover); }
        .ignored-words-textarea { width: 100%; min-height: 120px; max-height: 300px; padding: 8px; border: 1px solid var(--border); border-radius: 4px; font-family: monospace; font-size: 13px; resize: vertical; line-height: 1.5; background: var(--text-area-bg); color: var(--text); }
        .ignored-words-textarea:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.1); }
        .toast-notification { position: fixed; top: 20px; right: 20px; background: var(--success); color: white; padding: 12px 20px; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.2); z-index: 3000; font-size: 14px; animation: slideInRight 0.3s ease-out; }
        @keyframes slideInRight { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slideOutRight { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } }
        .toast-notification.hide { animation: slideOutRight 0.3s ease-out; }
        @media (max-width: 600px) { .container { padding: 16px; } .header-actions { flex-direction: column; width: 100%; } .status-row { flex-direction: column; align-items: stretch; } .ai-button-bottom { width: 100%; } .tips-row { flex-direction: column; gap: 4px; } .tips-row span { text-align: left !important; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-left">
                <h1>SecSpell</h1>
                <span class="subtitle">Offline, privacy-focused, open-source</span>
            </div>
            <div class="header-actions">
            <div class="language-selector">
                    <label>Language:</label>
                    <div class="radio-group" id="languageRadioGroup">
                        <!-- Dynamically generated -->
                    </div>
                </div>
                <button class="settings-button" id="settingsButton" title="Settings" onclick="openSettings()">‚öôÔ∏è</button>
            </div>
        </div>
    
        <div id="text-area" contenteditable="true" spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Type your text here..."></div>
        <div id="loading" class="loading" style="display: none;">Loading dictionaries...</div>
            <div class="tips-row" style="display: flex; justify-content: space-between; align-items: center; font-size: 12px; color: var(--text-muted); margin-top: 8px;">
            <span>üí° Press Esc to force spell check</span>
            <span id="aiWarning">‚ö†Ô∏è Never send sensitive text to AI service:</span>
        </div>
        <div class="status-row">
        <div id="status" class="status"></div>
            <button class="ai-button-bottom" id="aiButton" title="Copy text and open DuckDuckGo AI Chat (anonymous, privacy-focused)" onclick="openInDuckDuckGoAI()">
                ü§ñ Copy & Open AI Chat
            </button>
        </div>
        <div id="suggestions-menu" class="suggestions-menu"></div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="settings-modal" onclick="handleSettingsModalClick(event)">
        <div class="settings-content" onclick="event.stopPropagation()">
            <div class="settings-header">
                <h2>Settings</h2>
                <button class="settings-close" onclick="closeSettings()" title="Close">√ó</button>
            </div>
            <div class="settings-item">
                <label>
                    <input type="checkbox" id="settingDarkMode" onchange="handleDarkModeToggle()">
                    <span>Dark mode</span>
                </label>
                <div class="settings-item-description">Use dark color scheme</div>
            </div>
            <div class="settings-item">
                <label>
                    <input type="checkbox" id="settingAiEnabled" onchange="handleAiToggle()">
                    <span>Show AI Chat button</span>
                </label>
                <div class="settings-item-description">Enable the button to copy text and open DuckDuckGo AI Chat</div>
                <div class="settings-item-description" style="color: var(--danger); margin-top: 4px;">‚ö†Ô∏è Warning: AI service sends your text to external servers. Do not use for sensitive or confidential information.</div>
            </div>
            <div class="settings-item">
                <label>
                    <input type="checkbox" id="settingAutosave" onchange="handleAutosaveToggle()">
                    <span>Autosave text</span>
                </label>
                <div class="settings-item-description">Automatically save your text and restore it when you return</div>
                <div class="settings-item-description" style="color: var(--danger); margin-top: 4px;">‚ö†Ô∏è Warning: Saved text is stored unencrypted in your browser's localStorage. Do not use for sensitive information.</div>
            </div>
            <div id="clearTextContainer" class="settings-item" style="display: none;">
                <div id="lastSavedTime" class="settings-item-description" style="margin-bottom: 8px; font-weight: 500;"></div>
                <button class="settings-button-danger" onclick="handleClearSavedText()">Clear saved text</button>
            </div>
            <div class="settings-separator"></div>
            <div class="settings-item">
                <div style="font-weight: 500; margin-bottom: 8px;">Ignored Words (Personal Dictionary)</div>
                <div class="settings-item-description" style="margin-bottom: 8px;">Words you've chosen to ignore. Enter one word per line or comma-separated. Changes save automatically.</div>
                <textarea id="ignoredWordsTextarea" class="ignored-words-textarea" placeholder="Enter words to ignore, one per line or comma-separated&#10;Example:&#10;customword&#10;technicalterm&#10;brandname"></textarea>
                <div style="display: flex; gap: 8px; margin-top: 8px;">
                    <button class="settings-button" onclick="handleSaveIgnoredWords()" style="padding: 6px 12px; font-size: 13px;">Save Changes</button>
                    <button class="settings-button-danger" onclick="handleClearAllIgnoredWords()" style="padding: 6px 12px; font-size: 13px;" id="clearAllIgnoredBtn">Clear All</button>
                </div>
                <div id="ignoredWordsCount" class="settings-item-description" style="margin-top: 4px; font-style: italic;"></div>
            </div>
            <div class="settings-separator"></div>
            <div class="settings-item">
                <a href="tools/converter.html" class="settings-link" target="_blank">üîß Dictionary Converter</a>
                <div class="settings-item-description">Convert and add new language dictionaries</div>
            </div>
            <div class="settings-item">
                <a href="tools/tests.html" class="settings-link" target="_blank">üß™ Test Suite</a>
                <div class="settings-item-description">Run comprehensive tests for dictionary loading, spell checking, and performance</div>
            </div>
            <div class="settings-item">
                <button id="runIntegrationTests" class="settings-link" style="background: none; border: none; padding: 0; cursor: pointer; text-align: left;">üß™ Integration Tests</button>
                <div class="settings-item-description">Run integration tests simulating user interactions (requires dictionaries loaded)</div>
            </div>
        </div>
    </div>

    <script src="tools/typo.js"></script>
    <script src="tools/dictionaries-en_US.js"></script>
    <script src="tools/dictionaries-sv_SE.js"></script>

    <script>
        // Auto-detect available dictionaries
        function detectAvailableLanguages() {
            const languages = [];
            for (const key in window) {
                if (key.startsWith('dictionary_') && window[key] && window[key].aff && window[key].dic) {
                    const locale = key.replace('dictionary_', '');
                    const code = locale.split('_')[0]; // 'en' from 'en_US'
                    languages.push({ locale, code, name: getLanguageName(code, locale) });
                }
            }
            return languages.sort((a, b) => a.name.localeCompare(b.name));
        }
        
        function getLanguageName(code, locale) {
            const names = { en: 'English', sv: 'Swedish', de: 'German', fr: 'French', es: 'Spanish', 
                          it: 'Italian', pt: 'Portuguese', nl: 'Dutch', ru: 'Russian', ja: 'Japanese',
                          zh: 'Chinese', ko: 'Korean', pl: 'Polish', cs: 'Czech', tr: 'Turkish' };
            return names[code] || locale.replace('_', ' ').toUpperCase();
        }
        
        // ====== CONSTANTS ======
        const PLACEHOLDER_TEXT = 'Type here to check spelling...';
        const STORAGE_KEYS = {
            IGNORED: 'spellcheck-ignored',
            AI_ENABLED: 'spellcheck-ai-enabled',
            AUTOSAVE: 'spellcheck-autosave',
            AUTOSAVED_TEXT: 'spellcheck-autosaved-text',
            LAST_SAVED: 'spellcheck-last-saved',
            DARK_MODE: 'spellcheck-dark-mode'
        };
        
        // ====== CONFIGURATION ======
        const CONFIG = {
            SPELL_CHECK_IDLE_DELAY: 2000,  // Check after 2 seconds of no typing
            SUGGESTION_HOVER_DELAY: 300,
            SUGGESTION_HIDE_DELAY: 200,
            MAX_CACHE_SIZE: 100,
            MAX_UNDO_HISTORY: 50,
            PRE_CACHE_WORD_COUNT: 10,  // Pre-cache suggestions for first N misspelled words
            PRE_CACHE_DELAY: 100,  // Delay between each word's suggestion pre-caching (ms)
            AUTOSAVE_DELAY: 2000  // Save text after 2 seconds of no typing
        };
        
        // ====== STORAGE UTILITY ======
        const Storage = {
            get(key, defaultValue = null) {
                try {
                    const value = localStorage.getItem(key);
                    return value !== null ? value : defaultValue;
                } catch (e) {
                    console.error(`Failed to read ${key}:`, e);
                    return defaultValue;
                }
            },
            
            set(key, value) {
                try {
                    localStorage.setItem(key, typeof value === 'string' ? value : JSON.stringify(value));
                    return true;
                } catch (e) {
                    if (e.name === 'QuotaExceededError') {
                        showToast('Storage full. Please clear some data.', 4000);
                    } else {
                        console.error(`Failed to save ${key}:`, e);
                    }
                    return false;
                }
            },
            
            remove(key) {
                try {
                    localStorage.removeItem(key);
                    return true;
                } catch (e) {
                    console.error(`Failed to remove ${key}:`, e);
                    return false;
                }
            },
            
            getJSON(key, defaultValue = null) {
                try {
                    const value = this.get(key);
                    return value ? JSON.parse(value) : defaultValue;
                } catch (e) {
                    console.error(`Failed to parse ${key}:`, e);
                    return defaultValue;
                }
            },
            
            setJSON(key, value) {
                return this.set(key, JSON.stringify(value));
            }
        };
        
        // ====== TIMEOUT MANAGER ======
        const TimeoutManager = {
            timeouts: new Map(),
            
            set(name, callback, delay) {
                this.clear(name);
                this.timeouts.set(name, setTimeout(callback, delay));
            },
            
            clear(name) {
                const timeout = this.timeouts.get(name);
                if (timeout) {
                    clearTimeout(timeout);
                    this.timeouts.delete(name);
                }
            },
            
            clearAll() {
                this.timeouts.forEach(timeout => clearTimeout(timeout));
                this.timeouts.clear();
            }
        };
        
        // ====== DOM UTILITIES ======
        const DOMUtils = {
            createElement(tag, className = null, textContent = null, attributes = {}) {
                const el = document.createElement(tag);
                if (className) el.className = className;
                if (textContent) el.textContent = textContent;
                Object.entries(attributes).forEach(([key, value]) => {
                    el.setAttribute(key, value);
                });
                return el;
            },
            
            createMenuItem(text, onClick = null, attributes = {}) {
                const item = this.createElement('div', 'suggestion-item', text, attributes);
                if (onClick) item.addEventListener('click', onClick);
                return item;
            }
        };
        
        // ====== TEXT UTILITIES ======
        const TextUtils = {
            get() {
                return getPlainText(DOM.textArea);
            },
            
            set(value) {
                DOM.textArea.textContent = value;
            },
            
            isEmpty() {
                const text = this.get();
                return !text || text.trim() === '' || text === PLACEHOLDER_TEXT;
            },
            
            isPlaceholder() {
                return this.get() === PLACEHOLDER_TEXT;
            },
            
            forceRecheck() {
                lastTextContent = '';
                performSpellCheck();
            }
        };
        
        // ====== STATE MANAGEMENT ======
        const availableLanguages = detectAvailableLanguages();
        const dictionaries = new Map();
        let languageMode = 'all', undoStack = [], redoStack = [], isUndoRedoAction = false;
        let suggestionCache = new Map(), isDictionaryLoading = false;
        let ignoredWords = new Set(Storage.getJSON(STORAGE_KEYS.IGNORED, []));
        let selectedSuggestionIndex = -1, lastTextContent = '', isLanguageSwitching = false;
        let savedCursorPosition = null, enterKeyPressed = false;
        let isPreCaching = false;
        
        // ====== SETTINGS MANAGEMENT ======
        const settings = {
            get(key, def = true) {
                const val = Storage.get(`spellcheck-${key}`);
                return val === null ? def : val === 'true';
            },
            
            set(key, value) {
                Storage.set(`spellcheck-${key}`, value.toString());
            },
            
            getBoolean(key, defaultValue = true) {
                return this.get(key, defaultValue);
            },
            
            getString(key, defaultValue = '') {
                return Storage.get(`spellcheck-${key}`, defaultValue);
            },
            
            batchUpdate(updates) {
                Object.entries(updates).forEach(([key, value]) => {
                    this.set(key, value);
                });
                this.apply();
            },
            
            apply() {
                const aiEnabled = this.get('ai-enabled');
                DOM.aiButton.style.display = aiEnabled ? '' : 'none';
                DOM.aiWarning.style.display = aiEnabled ? '' : 'none';
                DOM.settingAiCheckbox.checked = aiEnabled;
                DOM.settingAutosaveCheckbox.checked = this.get('autosave');
                this.updateClearButton();
            },
            
            updateClearButton() {
                const hasText = Storage.get(STORAGE_KEYS.AUTOSAVED_TEXT);
                const lastSaved = Storage.get(STORAGE_KEYS.LAST_SAVED);
                DOM.clearTextContainer.style.display = (this.get('autosave') && hasText) ? 'block' : 'none';
                if (lastSaved && DOM.lastSavedTime) {
                    const date = new Date(parseInt(lastSaved));
                    DOM.lastSavedTime.textContent = `Last saved: ${date.toLocaleString()}`;
                    DOM.lastSavedTime.style.display = lastSaved ? 'block' : 'none';
                }
            }
        };
        
        function openSettings() {
            const modal = document.getElementById('settingsModal');
            if (modal) {
                settings.updateClearButton();
                updateIgnoredWordsList();
                modal.classList.add('show');
            }
        }
        
        function closeSettings() {
            const modal = document.getElementById('settingsModal');
            if (modal) modal.classList.remove('show');
        }
        
        function handleSettingsModalClick(event) {
            if (event.target.id === 'settingsModal') closeSettings();
        }
        
        function applyTheme(isDark) {
            if (isDark) {
                document.documentElement.setAttribute('data-theme', 'dark');
            } else {
                document.documentElement.removeAttribute('data-theme');
            }
        }
        
        function getSystemDarkModePreference() {
            return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
        }
        
        function initDarkMode() {
            const saved = Storage.get(STORAGE_KEYS.DARK_MODE);
            const isDark = saved !== null ? saved === 'true' : getSystemDarkModePreference();
            
            applyTheme(isDark);
            if (DOM.settingDarkModeCheckbox) {
                DOM.settingDarkModeCheckbox.checked = isDark;
            }
        }
        
        function createSettingHandler(settingKey, callback = null) {
            return function() {
                const checkbox = document.getElementById(`setting${settingKey}`);
                const value = checkbox?.checked ?? true;
                
                if (settingKey === 'DarkMode') {
                    Storage.set(STORAGE_KEYS.DARK_MODE, value.toString());
                    applyTheme(value);
                } else {
                    const key = settingKey.replace(/([A-Z])/g, '-$1').toLowerCase().replace(/^-/, '');
                    settings.set(key, value);
                    if (callback) callback(value);
                    else settings.apply();
                }
            };
        }
        
        window.handleDarkModeToggle = createSettingHandler('DarkMode');
        window.handleAiToggle = createSettingHandler('AiEnabled');
        window.handleAutosaveToggle = createSettingHandler('Autosave', (enabled) => {
            if (enabled) {
                scheduleAutosave(0);
            } else {
                Storage.remove(STORAGE_KEYS.AUTOSAVED_TEXT);
                Storage.remove(STORAGE_KEYS.LAST_SAVED);
                settings.updateClearButton();
            }
            settings.apply();
        });
        
        function handleClearSavedText() {
            if (confirm('Are you sure you want to clear the saved text? This cannot be undone.')) {
                Storage.remove(STORAGE_KEYS.AUTOSAVED_TEXT);
                Storage.remove(STORAGE_KEYS.LAST_SAVED);
                settings.updateClearButton();
                showToast('Saved text cleared', 2000);
            }
        }
        
        function scheduleAutosave(delay = CONFIG.AUTOSAVE_DELAY) {
            if (!settings.get('autosave')) return;
            TimeoutManager.set('autosave', () => {
                const text = TextUtils.get();
                if (text && text !== PLACEHOLDER_TEXT) {
                    Storage.set(STORAGE_KEYS.AUTOSAVED_TEXT, text);
                    Storage.set(STORAGE_KEYS.LAST_SAVED, Date.now().toString());
                } else {
                    Storage.remove(STORAGE_KEYS.AUTOSAVED_TEXT);
                    Storage.remove(STORAGE_KEYS.LAST_SAVED);
                }
                settings.updateClearButton();
            }, delay);
        }
        
        function restoreSavedText() {
            if (!settings.get('autosave')) return;
            const savedText = Storage.get(STORAGE_KEYS.AUTOSAVED_TEXT);
            if (!savedText?.trim() || !DOM.textArea) return;
            const currentText = TextUtils.get();
            if (TextUtils.isEmpty()) {
                TextUtils.set(savedText);
                lastTextContent = '';
                undoStack = [savedText];
                redoStack = [];
                TimeoutManager.set('restoreCheck', () => {
                    if (DOM.textArea !== document.activeElement) performSpellCheck();
                }, 100);
            }
        }
        
        // ====== DOM CACHE ======
        const DOM = {
            textArea: null,
            menu: null,
            statusDiv: null,
            aiButton: null,
            aiWarning: null,
            settingDarkModeCheckbox: null,
            settingAiCheckbox: null,
            settingAutosaveCheckbox: null,
            clearTextContainer: null,
            lastSavedTime: null,
            loadingDiv: null,
            radioGroup: null,
            ignoredWordsTextarea: null,
            clearAllIgnoredBtn: null,
            ignoredWordsCount: null
        };
        function scheduleSpellCheck(delay = 0) {
            TimeoutManager.set('spellCheck', performSpellCheck, delay);
        }
        
        function performSpellCheckWithCursorRestore() {
            const wasFocused = DOM.textArea === document.activeElement;
            isLanguageSwitching = true;
            
            if (wasFocused) {
                savedCursorPosition = saveCursorPosition();
                DOM.textArea.blur();
                TimeoutManager.set('spellCheckDelayed', () => {
                    performSpellCheck();
                    TimeoutManager.set('restoreCursor', () => {
                        if (savedCursorPosition !== null) {
                            DOM.textArea.focus();
                            restoreCursorPosition(savedCursorPosition);
                            savedCursorPosition = null;
                        }
                        isLanguageSwitching = false;
                    }, 10);
                }, 20);
            } else {
                performSpellCheck();
                isLanguageSwitching = false;
            }
        }
        
        function triggerSpellCheckWithCursor() {
            savedCursorPosition = saveCursorPosition();
            DOM.textArea.blur(); // This triggers spell check and cursor restore
        }
        
        // ====== UTILITIES ======
        function cleanWord(word) {
            return word?.toLowerCase().replace(/[^\p{L}\p{M}]/gu, '') || '';
        }
        
        function decodeBase64ToUTF8(base64String) {
            return new TextDecoder('utf-8').decode(new Uint8Array([...atob(base64String)].map(c => c.charCodeAt(0))));
        }
        
        function loadDictionary(locale) {
            return new Promise((resolve) => {
                // Validate locale format to prevent injection (alphanumeric and underscores only)
                if (!locale || !/^[a-zA-Z0-9_]+$/.test(locale)) {
                    console.error(`Invalid locale format: ${locale}`);
                    resolve(null);
                    return;
                }
                
                const dictVarName = `dictionary_${locale}`;
                if (!window[dictVarName]) {
                    console.error(`Dictionary ${locale} not found`);
                    resolve(null);
                    return;
                }
                
                try {
                    const dictData = window[dictVarName];
                    const affData = decodeBase64ToUTF8(dictData.aff);
                    const dicData = decodeBase64ToUTF8(dictData.dic);
                    const dict = new Typo(locale, affData, dicData);
                    
                    if (dict && dict.check && dict.loaded) {
                        disableCompoundRules(dict);
                        resolve(dict);
                    } else {
                        console.error(`Dictionary ${locale} failed to initialize`);
                        resolve(null);
                    }
                } catch (e) {
                    console.error(`Error loading dictionary ${locale}:`, e);
                    resolve(null);
                }
            });
        }
        
        function disableCompoundRules(dict) {
            if (dict.compoundRules) { dict.compoundRules = []; delete dict.flags.COMPOUNDMIN; }
        }
        
        function loadDictionaries(forceAll = false) {
            if (isDictionaryLoading) return Promise.resolve();
            isDictionaryLoading = true;
            const toLoad = [];
            const localesToLoad = forceAll || languageMode === 'all' 
                ? availableLanguages.map(l => l.locale)
                : [availableLanguages.find(l => l.code === languageMode)?.locale].filter(Boolean);
            localesToLoad.forEach(locale => {
                if (locale && !dictionaries.has(locale)) {
                    toLoad.push(loadDictionary(locale).then(dict => { 
                        if (dict) dictionaries.set(locale, dict); 
                    }));
                }
            });
            // If nothing to load, resolve immediately
            if (toLoad.length === 0) {
                isDictionaryLoading = false;
                return Promise.resolve();
            }
            return Promise.all(toLoad).finally(() => { isDictionaryLoading = false; });
        }
        function loadAllDictionaries() { return loadDictionaries(true); }
        
        // ====== SPELL CHECKING ======
        function getRequiredDictionaries() {
            return languageMode === 'all'
                ? availableLanguages.map(l => l.locale)
                : [availableLanguages.find(l => l.code === languageMode)?.locale].filter(Boolean);
        }
        
        function getActiveDictionaries() {
            return languageMode === 'all' 
                ? Array.from(dictionaries.values())
                : [dictionaries.get(availableLanguages.find(l => l.code === languageMode)?.locale)].filter(Boolean);
        }
        
        function getSuggestions(word, limit = 5) {
            const cleaned = cleanWord(word);
            if (!cleaned) return [];
            
            // Check cache first
            const cacheKey = `${languageMode}:${cleaned}:${limit}`;
            if (suggestionCache.has(cacheKey)) {
                return suggestionCache.get(cacheKey);
            }
            
            let suggestions = [];
            const activeDicts = getActiveDictionaries();
            
            activeDicts.forEach(dict => {
                if (dict && dict.suggest) {
                    suggestions.push(...dict.suggest(cleaned, limit));
                }
            });
            
                // Remove duplicates and limit
                suggestions = [...new Set(suggestions)].slice(0, limit);
            
            if (suggestionCache.size >= CONFIG.MAX_CACHE_SIZE) suggestionCache.delete(suggestionCache.keys().next().value);
            suggestionCache.set(cacheKey, suggestions);
            
            return suggestions;
        }
        
        function checkWord(word) {
            const cleaned = cleanWord(word);
            if (!cleaned) return true;
            if (ignoredWords.has(cleaned)) return true;
            
            const activeDicts = getActiveDictionaries();
            return activeDicts.some(dict => dict && dict.check && dict.check(cleaned));
        }
        
        function toggleIgnoreList(word, add) {
            const cleaned = cleanWord(word);
            if (!cleaned) return;
            if (add) ignoredWords.add(cleaned);
            else if (ignoredWords.has(cleaned)) ignoredWords.delete(cleaned);
            else return;
            
            if (!Storage.setJSON(STORAGE_KEYS.IGNORED, [...ignoredWords])) {
                showToast('Storage full. Could not save ignored word.', 3000);
                return;
            }
            TextUtils.forceRecheck();
            updateIgnoredWordsList();
        }
        
        function updateIgnoredWordsList() {
            if (!DOM.ignoredWordsTextarea) return;
            
            const words = Array.from(ignoredWords).sort();
            DOM.ignoredWordsTextarea.value = words.join('\n');
            
            // Update count
            if (DOM.ignoredWordsCount) {
                if (words.length === 0) {
                    DOM.ignoredWordsCount.textContent = 'No ignored words yet. Right-click a misspelled word to ignore it.';
                } else {
                    DOM.ignoredWordsCount.textContent = `${words.length} word${words.length !== 1 ? 's' : ''} ignored`;
                }
            }
            
            if (DOM.clearAllIgnoredBtn) {
                DOM.clearAllIgnoredBtn.style.display = words.length > 0 ? 'inline-block' : 'none';
            }
        }
        
        function parseIgnoredWordsText(text) {
            // Split by commas, newlines, or semicolons, then clean and filter
            return text
                .split(/[,\n;]+/)
                .map(word => cleanWord(word.trim()))
                .filter(word => word.length > 0);
        }
        
        function handleSaveIgnoredWords() {
            if (!DOM.ignoredWordsTextarea) return;
            
            const text = DOM.ignoredWordsTextarea.value;
            const newWords = parseIgnoredWordsText(text);
            ignoredWords = new Set(newWords);
            
            if (!Storage.setJSON(STORAGE_KEYS.IGNORED, [...ignoredWords])) {
                showToast('Storage full. Could not save ignored words.', 3000);
                return;
            }
            
            showToast(`Saved ${ignoredWords.size} ignored word${ignoredWords.size !== 1 ? 's' : ''}`, 2000);
            TextUtils.forceRecheck();
            updateIgnoredWordsList();
        }
        
        window.handleSaveIgnoredWords = handleSaveIgnoredWords;
        
        function clearAllIgnoredWords() {
            if (!confirm('Clear all ignored words from your personal dictionary?')) return;
            ignoredWords.clear();
            Storage.remove(STORAGE_KEYS.IGNORED);
            showToast('All ignored words cleared', 2000);
            TextUtils.forceRecheck();
            updateIgnoredWordsList();
        }
        
        window.handleClearAllIgnoredWords = clearAllIgnoredWords;
        
        // Test integration (only loads when needed)
        let testIntegrationLoaded = false;
        let testIntegrationLoading = false;
        
        function loadTestIntegration() {
            return new Promise((resolve, reject) => {
                if (testIntegrationLoaded) {
                    resolve();
                    return;
                }
                if (testIntegrationLoading) {
                    // Wait for existing load to complete
                    const checkLoaded = setInterval(() => {
                        if (testIntegrationLoaded) {
                            clearInterval(checkLoaded);
                            resolve();
                        }
                    }, 100);
                    setTimeout(() => {
                        clearInterval(checkLoaded);
                        reject(new Error('Timeout waiting for test integration to load'));
                    }, 5000);
                    return;
                }
                
                testIntegrationLoading = true;
                const script = document.createElement('script');
                script.src = 'tools/test-integration.js';
                script.onload = () => {
                    testIntegrationLoaded = true;
                    testIntegrationLoading = false;
                    // Give it a moment to execute
                    setTimeout(() => {
                        if (window.runIntegrationTests) {
                            resolve();
                        } else {
                            reject(new Error('Test integration loaded but function not available'));
                        }
                    }, 100);
                };
                script.onerror = () => {
                    testIntegrationLoading = false;
                    testIntegrationLoaded = false;
                    reject(new Error('Failed to load test integration file'));
                };
                document.head.appendChild(script);
            });
        }
        
        // Handle integration test button
        document.addEventListener('DOMContentLoaded', () => {
            const testBtn = document.getElementById('runIntegrationTests');
            if (testBtn) {
                testBtn.addEventListener('click', async () => {
                    try {
                        await loadTestIntegration();
                        if (typeof window.runIntegrationTests === 'function') {
                            window.runIntegrationTests();
                        } else {
                            showToast('Test integration not available', 3000);
                        }
                    } catch (e) {
                        showToast('Failed to load test integration: ' + e.message, 3000);
                        console.error('Test integration error:', e);
                    }
                });
            }
        });
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function highlightErrors(text) {
            if (!text) return '';
            const parts = text.split(/(\s+|[^\p{L}\p{M}]+)/u);
            return parts.map(part => {
                if (!part || /^\s+$/.test(part) || /^[^\p{L}\p{M}]+$/u.test(part)) {
                    return escapeHtml(part);
                }
                const cleaned = cleanWord(part);
                const isIgnored = cleaned && ignoredWords.has(cleaned);
                const isCorrect = checkWord(part);
                
                if (isIgnored) {
                    return `<span class="spell-ignored" data-word="${escapeHtml(part)}">${escapeHtml(part)}</span>`;
                }
                if (!isCorrect) {
                    return `<span class="spell-error" data-word="${escapeHtml(part)}">${escapeHtml(part)}</span>`;
                }
                return escapeHtml(part);
            }).join('');
        }
        
        // ====== TEXT EXTRACTION ======
        function getPlainText(element) {
            return element.innerText || element.textContent || '';
        }
        
        // ====== CURSOR POSITION ======
        function saveCursorPosition() {
            const selection = window.getSelection();
            if (!selection || selection.rangeCount === 0) return null;
            const range = selection.getRangeAt(0);
            if (!DOM.textArea.contains(range.commonAncestorContainer)) return null;
            
            // Count characters before cursor
            const preRange = range.cloneRange();
            preRange.selectNodeContents(DOM.textArea);
            preRange.setEnd(range.endContainer, range.endOffset);
            
            return preRange.toString().length;
        }
        
        function restoreCursorPosition(position) {
            if (position === null || position === undefined) return;
            const text = TextUtils.get();
            
            // Clamp position to valid range
            position = Math.min(position, text.length);
            
            const selection = window.getSelection();
            const range = document.createRange();
            
            let charCount = 0;
            let found = false;
            
            const walker = document.createTreeWalker(DOM.textArea, NodeFilter.SHOW_TEXT, null);
            
            let node;
            while ((node = walker.nextNode())) {
                const nodeLength = node.textContent.length;
                if (charCount + nodeLength >= position) {
                    const offset = position - charCount;
                    range.setStart(node, offset);
                    range.setEnd(node, offset);
                    found = true;
                    break;
                }
                charCount += nodeLength;
            }
            
            if (!found) {
                // Position at end if not found
                range.selectNodeContents(DOM.textArea);
                range.collapse(false);
            }
            
            selection.removeAllRanges();
            selection.addRange(range);
        }
        
        function performSpellCheck() {
            if (DOM.textArea === document.activeElement) return;
            
            const text = TextUtils.get();
            if (text === lastTextContent) return;
            lastTextContent = text;
            
            if (!text.trim() && DOM.textArea.childNodes.length === 0) {
                updateStatus();
                return;
            }
            
            const requiredDicts = getRequiredDictionaries();
            if (requiredDicts.some(locale => !dictionaries.has(locale))) return;
            
            // Perform spell check (cursor is NOT in text area, so safe!)
            // Note: innerHTML usage here is safe - all user content is escaped via highlightErrors() ‚Üí escapeHtml()
            // Only safe HTML tags (<span> with data-word attributes) are injected, never raw user content
            const highlighted = highlightErrors(text);
            const htmlWithBreaks = highlighted.replace(/\n/g, '<br>');
            
            // Only update if HTML changed
            const currentHtml = DOM.textArea.innerHTML.replace(/\s+/g, ' ').trim();
            const newHtml = htmlWithBreaks.replace(/\s+/g, ' ').trim();
            
            if (currentHtml !== newHtml) {
                DOM.textArea.innerHTML = htmlWithBreaks;
            }
            
            updateStatus();
            preCacheSuggestions();
        }
        
        function preCacheSuggestions() {
            TimeoutManager.clear('preCache');
            if (isPreCaching) return;
            
            // Get first N misspelled words
            const errorElements = document.querySelectorAll('.spell-error');
            if (errorElements.length === 0) return;
            
            const wordsToCache = Array.from(errorElements)
                .slice(0, CONFIG.PRE_CACHE_WORD_COUNT)
                .map(el => el.getAttribute('data-word'))
                .filter(Boolean)
                .filter(word => {
                    const cleaned = cleanWord(word);
                    const cacheKey = `${languageMode}:${cleaned}:8`;
                    return !suggestionCache.has(cacheKey);
                });
            
            if (wordsToCache.length === 0) return;
            
            isPreCaching = true;
            let index = 0;
            
            const cacheNext = () => {
                if (index >= wordsToCache.length || isLanguageSwitching) {
                    isPreCaching = false;
                    return;
                }
                
                const word = wordsToCache[index];
                if (word) getSuggestions(word, 8);
                
                index++;
                if (index < wordsToCache.length) {
                    TimeoutManager.set('preCache', cacheNext, CONFIG.PRE_CACHE_DELAY);
                } else {
                    isPreCaching = false;
                }
            };
            
            TimeoutManager.set('preCache', cacheNext, 200);
        }
        
        function positionMenu(menu, rect) {
            menu.style.top = (rect.bottom + 2) + 'px';
            menu.style.left = rect.left + 'px';
            
            TimeoutManager.set('menuPosition', () => {
                const menuRect = menu.getBoundingClientRect();
                if (menuRect.right > window.innerWidth) {
                    menu.style.left = (window.innerWidth - menuRect.width - 10) + 'px';
                }
                if (menuRect.bottom > window.innerHeight) {
                    menu.style.top = (rect.top - menuRect.height - 2) + 'px';
                }
            }, 0);
        }
        
        let currentSuggestionWord = null; // Store word for event delegation
        
        function showSuggestions(word, element, isIgnoredWord = false) {
            const rect = element.getBoundingClientRect();
            const cleaned = cleanWord(word);
            const isIgnored = ignoredWords.has(cleaned);
            const suggestions = isIgnored ? [] : getSuggestions(word, 8);
            
            DOM.menu.innerHTML = '';
            selectedSuggestionIndex = -1;
            currentSuggestionWord = word;
            
            // Add suggestion items
            suggestions.forEach(s => {
                DOM.menu.appendChild(DOMUtils.createMenuItem(s, null, { 'data-replace': s }));
            });
            
            // Add "No suggestions found" if needed
            if (suggestions.length === 0 && !isIgnored) {
                DOM.menu.appendChild(DOMUtils.createElement('div', 'suggestion-item', 'No suggestions found'));
            }
            
            // Add ignore button
            const ignoreButton = DOMUtils.createElement('div', 'suggestion-item', 
                isIgnored ? 'Remove from ignore list' : 'Ignore word', 
                { 'data-action': 'ignore' });
            ignoreButton.style.borderTop = '1px solid var(--border-light)';
            ignoreButton.style.marginTop = '4px';
            ignoreButton.style.paddingTop = '8px';
            DOM.menu.appendChild(ignoreButton);
            
            positionMenu(DOM.menu, rect);
            DOM.menu.classList.add('show');
        }
        
        function hideSuggestions() {
            DOM.menu.classList.remove('show');
            selectedSuggestionIndex = -1;
        }
        
        function saveState(force = false) {
            if (isUndoRedoAction) return;
            const currentText = TextUtils.get();
            if (!force && undoStack.length > 0 && undoStack[undoStack.length - 1] === currentText) return;
            undoStack.push(currentText); 
            redoStack = [];
            if (undoStack.length > CONFIG.MAX_UNDO_HISTORY) undoStack.shift();
        }
        
        function performUndoRedo(sourceStack, targetStack) {
            if (sourceStack.length === 0) return;
            targetStack.push(TextUtils.get());
            isUndoRedoAction = true;
            TextUtils.set(sourceStack.pop());
            TextUtils.forceRecheck();
            performSpellCheckWithCursorRestore();
            isUndoRedoAction = false;
        }
        
        function undo() { performUndoRedo(undoStack, redoStack); }
        function redo() { performUndoRedo(redoStack, undoStack); }
        
        function replaceWord(oldWord, newWord) {
            saveState();
            TextUtils.set(TextUtils.get().replace(new RegExp(`\\b${oldWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi'), newWord));
            performSpellCheck();
        }
        
        function updateStatus() {
            const errors = document.querySelectorAll('.spell-error');
            DOM.statusDiv.className = 'status active' + (errors.length > 0 ? ' has-errors' : ' no-errors');
            DOM.statusDiv.textContent = errors.length > 0 ? `Found ${errors.length} error${errors.length === 1 ? '' : 's'}. Hover over highlighted words for suggestions.` : 'No spelling errors detected.';
        }
        
        // ====== CLIPBOARD UTILITIES ======
        function copyToClipboard(text) {
            return new Promise((resolve, reject) => {
                if (navigator.clipboard?.writeText) {
                    navigator.clipboard.writeText(text).then(resolve).catch(() => {
                        fallbackCopyToClipboard(text) ? resolve() : reject(new Error('Copy failed'));
                    });
                } else {
                    fallbackCopyToClipboard(text) ? resolve() : reject(new Error('Clipboard API not available'));
                }
            });
        }
        
        function fallbackCopyToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.cssText = 'position:fixed;opacity:0;left:-9999px';
            document.body.appendChild(textArea);
            textArea.select();
            try {
                const success = document.execCommand('copy');
                document.body.removeChild(textArea);
                return success;
            } catch (e) {
                document.body.removeChild(textArea);
                return false;
            }
        }
        
        function showToast(message, duration = 3000) {
            const toast = DOMUtils.createElement('div', 'toast-notification', message);
            document.body.appendChild(toast);
            
            TimeoutManager.set('toastHide', () => {
                toast.classList.add('hide');
                TimeoutManager.set('toastRemove', () => {
                    if (document.body.contains(toast)) {
                        document.body.removeChild(toast);
                    }
                }, 300);
            }, duration);
        }
        function openInDuckDuckGoAI() {
            const text = TextUtils.get().trim();
            if (!text) {
                showToast('Please enter some text first.', 2000);
                return;
            }
            
            // Copy to clipboard and open DuckDuckGo AI
            copyToClipboard(text).then(() => {
                window.open('https://duckduckgo.com/chat', '_blank');
                showToast('‚úì Text copied! DuckDuckGo AI opened. Paste (Ctrl+V) to start.');
                    }).catch((err) => {
                        console.error('Copy failed:', err);
                        // Still open the tab even if copy fails
                        window.open('https://duckduckgo.com/chat', '_blank');
                        showToast('‚ö† Could not copy to clipboard. Please copy manually.', 4000);
                    });
        }
        
        function init() {
            // Cache DOM elements
            DOM.textArea = document.getElementById('text-area');
            DOM.menu = document.getElementById('suggestions-menu');
            DOM.statusDiv = document.getElementById('status');
            DOM.radioGroup = document.getElementById('languageRadioGroup');
            DOM.loadingDiv = document.getElementById('loading');
            DOM.aiButton = document.getElementById('aiButton');
            DOM.aiWarning = document.getElementById('aiWarning');
            DOM.settingDarkModeCheckbox = document.getElementById('settingDarkMode');
            DOM.settingAiCheckbox = document.getElementById('settingAiEnabled');
            DOM.settingAutosaveCheckbox = document.getElementById('settingAutosave');
            
            // Initialize dark mode
            initDarkMode();
            
            // Listen for system theme changes (only if user hasn't set preference)
            if (window.matchMedia) {
                window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
                    if (Storage.get(STORAGE_KEYS.DARK_MODE) === null) {
                        applyTheme(e.matches);
                        if (DOM.settingDarkModeCheckbox) {
                            DOM.settingDarkModeCheckbox.checked = e.matches;
                        }
                    }
                });
            }
            DOM.clearTextContainer = document.getElementById('clearTextContainer');
            DOM.lastSavedTime = document.getElementById('lastSavedTime');
            DOM.ignoredWordsTextarea = document.getElementById('ignoredWordsTextarea');
            DOM.clearAllIgnoredBtn = document.getElementById('clearAllIgnoredBtn');
            DOM.ignoredWordsCount = document.getElementById('ignoredWordsCount');
            
            // Auto-save ignored words on blur (when user finishes editing)
            if (DOM.ignoredWordsTextarea) {
                DOM.ignoredWordsTextarea.addEventListener('blur', handleSaveIgnoredWords);
            }
            
            // Add loading spinner
            if (DOM.loadingDiv && !DOM.loadingDiv.querySelector('.spinner')) {
                DOM.loadingDiv.innerHTML = '<div class="spinner"></div> Loading dictionaries...';
            }
            
            // Apply settings (must be done before restore to show/hide AI button correctly)
            settings.apply();
            
            // Generate language selector
            if (availableLanguages.length > 0 && DOM.radioGroup) {
                const options = (availableLanguages.length > 1 ? [{code: 'all', name: 'All'}] : [])
                    .concat(availableLanguages)
                    .map(lang => `<div class="radio-option" onclick="document.getElementById('lang-${lang.code}').click()">
                        <input type="radio" name="language-mode" value="${lang.code}" id="lang-${lang.code}" ${lang.code === 'all' ? 'checked' : ''}>
                        <label for="lang-${lang.code}">${lang.name}</label></div>`).join('');
                DOM.radioGroup.innerHTML = options;
            }
            
            const langRadios = document.querySelectorAll('input[name="language-mode"]');
            
            // Only show loading if we actually have dictionaries to load
            if (availableLanguages.length > 0 && DOM.loadingDiv) {
                DOM.loadingDiv.classList.add('active');
                DOM.loadingDiv.style.display = '';
                TimeoutManager.set('initLoad', () => {
                    loadAllDictionaries().then(() => {
                        if (DOM.loadingDiv) {
                            DOM.loadingDiv.classList.remove('active');
                            DOM.loadingDiv.style.display = 'none';
                            DOM.loadingDiv.innerHTML = '<div class="spinner"></div> Loading dictionaries...';
                            DOM.loadingDiv.style.background = '';
                            DOM.loadingDiv.style.color = '';
                        }
                        restoreSavedText();
                        if (TextUtils.isEmpty() && !Storage.get(STORAGE_KEYS.AUTOSAVED_TEXT)) {
                            TextUtils.set(PLACEHOLDER_TEXT);
                        }
                        if (!TextUtils.isEmpty() && !TextUtils.isPlaceholder()) {
                            performSpellCheck();
                        }
                    }).catch(e => {
                        console.error('Failed to load dictionaries:', e);
                        if (DOM.loadingDiv) {
                            DOM.loadingDiv.classList.remove('active');
                            DOM.loadingDiv.style.display = 'none';
                            DOM.loadingDiv.innerHTML = '<div class="spinner"></div> Failed to load dictionaries. Please refresh.';
                            DOM.loadingDiv.style.background = '#ffebee';
                            DOM.loadingDiv.style.color = '#c62828';
                        }
                    });
                }, 50);
            } else {
                restoreSavedText();
                if (TextUtils.isEmpty() && !Storage.get(STORAGE_KEYS.AUTOSAVED_TEXT)) {
                    TextUtils.set(PLACEHOLDER_TEXT);
                }
            }
            // Save state on input (keystrokes, typing)
            DOM.textArea.addEventListener('input', () => {
                if (!isUndoRedoAction) saveState();
                lastTextContent = '';
                scheduleAutosave();
                
                // If Enter was just pressed, check immediately (newline already in DOM)
                if (enterKeyPressed) {
                    enterKeyPressed = false;
                    TimeoutManager.clear('idleCheck');
                    TimeoutManager.set('enterCheck', triggerSpellCheckWithCursor, 100);
                    return;
                }
                
                // Schedule spell check after idle period
                TimeoutManager.set('idleCheck', triggerSpellCheckWithCursor, CONFIG.SPELL_CHECK_IDLE_DELAY);
            });
            
            // Handle paste - save state BEFORE paste (so we can undo back to pre-paste state)
            DOM.textArea.addEventListener('paste', (e) => {
                if (!isUndoRedoAction) saveState(true);
                TimeoutManager.set('pasteSave', () => {
                    if (!isUndoRedoAction) saveState();
                    lastTextContent = '';
                    scheduleAutosave(500);
                }, 0);
            });
            
            // Handle cut - save state before cut (so we can undo back to pre-cut state)
            DOM.textArea.addEventListener('cut', () => {
                if (!isUndoRedoAction) saveState();
                TimeoutManager.set('cutSave', () => {
                    lastTextContent = '';
                    scheduleAutosave(500);
                }, 0);
            });
            
            // Spell check when user clicks away (leaves the text area)
            DOM.textArea.addEventListener('blur', () => {
                if (!isLanguageSwitching) {
                    scheduleSpellCheck(0);
                    scheduleAutosave(100);
                    
                    // Restore cursor if we have a saved position
                    if (savedCursorPosition !== null) {
                        TimeoutManager.set('restoreCursorBlur', () => {
                            DOM.textArea.focus();
                            restoreCursorPosition(savedCursorPosition);
                            savedCursorPosition = null;
                        }, 10);
                    }
                }
            });
            
            // ====== KEYBOARD HANDLERS ======
            const KeyboardHandlers = {
                handleEscape(e) {
                    const settingsModal = document.getElementById('settingsModal');
                    if (settingsModal?.classList.contains('show')) {
                        closeSettings();
                        e.preventDefault();
                        return true;
                    }
                    e.preventDefault();
                    TimeoutManager.clear('idleCheck');
                    lastTextContent = '';
                    triggerSpellCheckWithCursor();
                    return true;
                },
                
                handleSuggestionNavigation(e) {
                    if (!DOM.menu.classList.contains('show')) return false;
                    
                    const items = DOM.menu.querySelectorAll('.suggestion-item');
                    if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                        e.preventDefault();
                        selectedSuggestionIndex = e.key === 'ArrowDown' 
                            ? (selectedSuggestionIndex + 1) % items.length
                            : (selectedSuggestionIndex <= 0 ? items.length - 1 : selectedSuggestionIndex - 1);
                        items.forEach((item, i) => item.classList.toggle('highlighted', i === selectedSuggestionIndex));
                        items[selectedSuggestionIndex].scrollIntoView({ block: 'nearest' });
                        return true;
                    } else if (e.key === 'Enter' && selectedSuggestionIndex >= 0) {
                        e.preventDefault();
                        items[selectedSuggestionIndex].click();
                        return true;
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        hideSuggestions();
                        return true;
                    }
                    return false;
                },
                
                handleShortcuts(e) {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                        e.preventDefault();
                        undo();
                        return true;
                    } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                        e.preventDefault();
                        redo();
                        return true;
                    } else if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'I') {
                        e.preventDefault();
                        clearAllIgnoredWords();
                        return true;
                    }
                    return false;
                }
            };
            
            DOM.textArea.addEventListener('keydown', (e) => {
                // Handle large deletions
                if ((e.key === 'Delete' || e.key === 'Backspace') && (e.ctrlKey || e.metaKey)) {
                    if (!isUndoRedoAction) saveState();
                }
                
                // Handle Ctrl+A (select all)
                if ((e.ctrlKey || e.metaKey) && e.key === 'a' && !e.shiftKey) {
                    if (!isUndoRedoAction) {
                        TimeoutManager.set('selectAllSave', saveState, 10);
                    }
                }
                
                // Check on space
                if (e.key === ' ') {
                    TimeoutManager.clear('idleCheck');
                    TimeoutManager.set('spaceCheck', triggerSpellCheckWithCursor, 50);
                }
                
                // Mark Enter for checking in input event
                if (e.key === 'Enter') {
                    enterKeyPressed = true;
                }
                
                // Handle Escape
                if (e.key === 'Escape' && KeyboardHandlers.handleEscape(e)) return;
                
                // Handle suggestion menu navigation
                if (KeyboardHandlers.handleSuggestionNavigation(e)) return;
                
                // Handle keyboard shortcuts
                KeyboardHandlers.handleShortcuts(e);
            });
            langRadios.forEach(radio => {
                radio.addEventListener('change', function() {
                    if (!this.checked) return;
                    
                    suggestionCache.clear();
                    TimeoutManager.clear('preCache');
                    isPreCaching = false;
                    languageMode = this.value;
                    lastTextContent = '';
                    
                    const requiredDicts = getRequiredDictionaries();
                    if (requiredDicts.some(locale => !dictionaries.has(locale))) {
                        if (DOM.loadingDiv) DOM.loadingDiv.classList.add('active');
                    }
                    
                    loadDictionaries().then(() => {
                        if (DOM.loadingDiv) DOM.loadingDiv.classList.remove('active');
                        performSpellCheckWithCursorRestore();
                    });
                });
            });
            
            // ====== SUGGESTION MENU LOGIC ======
            const cancelMenuHide = () => TimeoutManager.clear('menuHide');
            const scheduleMenuHide = () => {
                cancelMenuHide();
                TimeoutManager.set('menuHide', () => {
                    if (!DOM.menu.matches(':hover') && !document.querySelector('.spell-error:hover') && !document.querySelector('.spell-ignored:hover')) {
                        hideSuggestions();
                    }
                }, CONFIG.SUGGESTION_HIDE_DELAY);
            };
            
            // Show suggestions on hover over misspelled or ignored word
            DOM.textArea.addEventListener('mouseover', (e) => {
                if (e.target.classList.contains('spell-error') || e.target.classList.contains('spell-ignored')) {
                    cancelMenuHide();
                    TimeoutManager.set('hoverDelay', () => {
                        const word = e.target.getAttribute('data-word');
                        if (word) showSuggestions(word, e.target, e.target.classList.contains('spell-ignored'));
                    }, CONFIG.SUGGESTION_HOVER_DELAY);
                }
            });
            
            // Hide when leaving word (if not moving to menu)
            DOM.textArea.addEventListener('mouseout', (e) => {
                if (e.target.classList.contains('spell-error') || e.target.classList.contains('spell-ignored')) {
                    scheduleMenuHide();
                }
            });
            
            // Event delegation for suggestion menu clicks
            DOM.menu.addEventListener('click', (e) => {
                const item = e.target.closest('.suggestion-item');
                if (!item) return;
                e.stopPropagation();
                if (!currentSuggestionWord) return;
                
                const word = currentSuggestionWord;
                const cleaned = cleanWord(word);
                const isIgnored = ignoredWords.has(cleaned);
                
                if (item.getAttribute('data-action') === 'ignore') {
                    toggleIgnoreList(word, !isIgnored);
                } else {
                    const replacement = item.getAttribute('data-replace');
                    if (replacement) replaceWord(word, replacement);
                }
                hideSuggestions();
            });
            
            // Keep menu visible when hovering over it
            DOM.menu.addEventListener('mouseenter', cancelMenuHide);
            DOM.menu.addEventListener('mouseleave', scheduleMenuHide);
            
            // Hide immediately when clicking outside
            document.addEventListener('click', (e) => {
                if (DOM.menu.classList.contains('show') && !DOM.menu.contains(e.target) && !e.target.classList.contains('spell-error') && !e.target.classList.contains('spell-ignored')) {
                    cancelMenuHide();
                    hideSuggestions();
                }
            });
            
            // Right-click context menu for managing ignored words
            DOM.textArea.addEventListener('contextmenu', (e) => {
                const target = e.target;
                
                // Check if clicking on a spell-error or spell-ignored span
                if (target.classList.contains('spell-error') || target.classList.contains('spell-ignored')) {
                    e.preventDefault();
                    const word = target.getAttribute('data-word');
                    if (!word) return;
                    
                    const cleaned = cleanWord(word);
                    const isIgnored = ignoredWords.has(cleaned);
                    
                    // Show menu with ignore/remove option
                    DOM.menu.innerHTML = '';
                    const ignoreItem = DOMUtils.createElement('div', 'suggestion-item', 
                        isIgnored ? 'Remove from ignore list' : 'Ignore word', 
                        { 'data-action': 'ignore' });
                    DOM.menu.appendChild(ignoreItem);
                    DOM.menu.style.top = e.pageY + 'px';
                    DOM.menu.style.left = e.pageX + 'px';
                    DOM.menu.classList.add('show');
                    
                    DOM.menu.querySelectorAll('.suggestion-item').forEach(item => {
                        item.addEventListener('click', () => {
                            toggleIgnoreList(word, !isIgnored);
                            hideSuggestions();
                        });
                    });
                    
                    // Hide on click outside
                    TimeoutManager.set('contextMenuHide', () => {
                        const hideOnClick = (clickE) => {
                            if (!DOM.menu.contains(clickE.target)) {
                                hideSuggestions();
                                document.removeEventListener('click', hideOnClick);
                            }
                        };
                        document.addEventListener('click', hideOnClick);
                    }, 0);
                }
            });
            
            ['contenteditable', 'spellcheck', 'autocomplete', 'autocorrect', 'autocapitalize'].forEach(attr => 
                DOM.textArea.setAttribute(attr, attr === 'contenteditable' ? 'true' : 'false'));
            
            // Don't set default text here - it's handled after dictionary loading in case we restore saved text
            DOM.textArea.addEventListener('focus', function() {
                if (this.textContent === PLACEHOLDER_TEXT) {
                    TextUtils.set('');
                    undoStack = [];
                    redoStack = [];
                    undoStack.push('');
                }
            });
            
            // Initialize undo stack - will be reset if saved text is restored
            undoStack.push('');
        }
        if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init); else init();
    </script>
</body>
</html>
